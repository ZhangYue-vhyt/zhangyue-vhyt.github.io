<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zhangyue-vhyt.github.io</id>
    <title>咸鱼の家</title>
    <updated>2020-05-10T16:31:21.374Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zhangyue-vhyt.github.io"/>
    <link rel="self" href="https://zhangyue-vhyt.github.io/atom.xml"/>
    <subtitle>海带缠潜艇，雾霾防激光。</subtitle>
    <logo>https://zhangyue-vhyt.github.io/images/avatar.png</logo>
    <icon>https://zhangyue-vhyt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 咸鱼の家</rights>
    <entry>
        <title type="html"><![CDATA[《C#高级编程》笔记：Chapter 4 Object-Oriented Programming]]></title>
        <id>https://zhangyue-vhyt.github.io/post/Professional-Csharp-Chapter4/</id>
        <link href="https://zhangyue-vhyt.github.io/post/Professional-Csharp-Chapter4/">
        </link>
        <updated>2020-05-10T04:30:07.000Z</updated>
        <content type="html"><![CDATA[<p>Processing</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《C#高级编程》笔记：Chapter 2 Core C#]]></title>
        <id>https://zhangyue-vhyt.github.io/post/Professional-Csharp-Chapter2/</id>
        <link href="https://zhangyue-vhyt.github.io/post/Professional-Csharp-Chapter2/">
        </link>
        <updated>2020-05-10T04:24:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="working-with-variables">WORKING WITH VARIABLES</h1>
<h2 id="initializing-variables-page-116">Initializing Variables: Page 116</h2>
<blockquote>
<p>C# has two methods for ensuring that variables are initialized before use:</p>
<ul>
<li>Variables that are fields in a class or struct, if not initialized explicitly, are by default zeroed out when they are created (classes and structs are discussed later).</li>
<li>Variables that are local to a method must be explicitly initialized in your code prior to any statements in which their values are used. In this case, the initialization doesn't have to happen when the variable is declared, but the compiler checks all possible paths through the method and flags an error if it detects any possibility of the value of a local variable being used before it is initialized.</li>
</ul>
</blockquote>
<h2 id="using-type-inference-page-118">Using Type Inference: Page 118</h2>
<p>Example:</p>
<pre><code class="language-cs">var someNumber = 0;
</code></pre>
<blockquote>
<p>There are a few rules that you need to follow:</p>
<ul>
<li>The variable must be initialized. Otherwise, the compiler doesn’t &gt; have anything from which to infer the type.</li>
<li>The initializer cannot be null.</li>
<li>The initializer must be an expression.</li>
<li>You can’t set the initializer to an object unless you create a new object in the initializer.</li>
</ul>
</blockquote>
<h2 id="understanding-variable-scope-page-119">Understanding Variable Scope: Page 119</h2>
<blockquote>
<p>The scope of a variable is the region of code from which the variable can be accessed. In general, the scope is determined by the following rules:</p>
<ul>
<li>A field (also known as a member variable) of a class is in scope for as long as a local variable of this type is in scope.</li>
<li>A local variable is in scope until a closing brace indicates the end of the block statement or method in which it was declared.</li>
<li>A local variable that is declared in a for, while, or similar statement is in scope in the body of that loop.</li>
</ul>
</blockquote>
<h2 id="working-with-constants-page-122">Working with Constants: Page 122</h2>
<p>Example:</p>
<pre><code class="language-cs">const int a = 100; // This value cannot be changed.
</code></pre>
<blockquote>
<p>Constants have the following characteristics:</p>
<ul>
<li>They must be initialized when they are declared. After a value has been assigned, it can never be overwritten.</li>
<li>The value of a constant must be computable at compile time. Therefore, you can't initialize a constant with a value taken from a variable. If you need to do this, you must use a read-only field (this is explained in Chapter 3).</li>
<li>Constants are always implicitly static. However, notice that you don't have to (and, in fact, are not permitted to) include the static modifier in the constant declaration.</li>
</ul>
</blockquote>
<blockquote>
<p>At least three advantages exist for using constants in your programs:</p>
<ul>
<li>Constants make your programs easier to read by replacing magic numbers and strings with readable names whose values are easy to understand.</li>
<li>Constants make your programs easier to modify. For example, assume that you have a SalesTax constant in one of your C# programs, and that constant is assigned a value of 6 percent. If the sales tax rate changes later, you can modify the behavior of all tax calculations simply by assigning a new value to the constant; you don’t have to hunt through your code for the value .06 and change each one, hoping you will find all of them.</li>
<li>Constants help prevent mistakes in your programs. If you attempt to assign another value to a constant somewhere in your program other than at the point where the constant is declared, the compiler flags the error.</li>
</ul>
</blockquote>
<h1 id="using-predefined-data-types-page-123">USING PREDEFINED DATA TYPES: Page 123</h1>
<h2 id="value-types-and-reference-types">Value Types and Reference Types</h2>
<blockquote>
<p>These types are stored in different places in memory; value types are stored in an area known as the <strong>stack</strong>, and reference types are stored in an area known as the <strong>managed heap</strong>.</p>
</blockquote>
<blockquote>
<ul>
<li>In C#, basic data types such as <em>bool</em> and <em>long</em> are <strong>value types</strong>. This means that if you declare a <em>bool</em> variable and assign it the value of another <em>bool</em> variable, you will have two separate <em>bool</em> values in memory. Later, if you change the value of the original <em>bool</em> variable, the value of the second <em>bool</em> variable does not change. These types are copied by value.</li>
<li>In contrast, most of the more complex C# data types, including <em>classes</em> that you yourself declare, are <strong>reference types</strong>. They are allocated upon the heap, have lifetimes that can span multiple function calls, and can be accessed through one or several aliases.</li>
<li>C# has been designed this way because high performance is best served by keeping primitive types (such as <strong>int</strong> and <strong>bool</strong>) as <em>value types</em>, and larger types that contain many fields (as is usually the case with <em>classes</em>) as <strong>reference types</strong>. If you want to define your own type as a value type, you should declare it as a <em>struct</em>.</li>
</ul>
</blockquote>
<h2 id="predefined-value-types">Predefined Value Types</h2>
<ul>
<li>Integer Types: Page 127.</li>
<li>Floating-Point Types: Page 130.</li>
<li>The Boolean Type: Page 132.</li>
<li>The Character Type: Page 132.</li>
</ul>
<h2 id="digit-separators">Digit Separators</h2>
<blockquote>
<p>C# 7 offers digit separators. These separators help with readability and don’t add any functionality. For example, you can add underscores to numbers, as shown in the following code snippet</p>
<pre><code class="language-cs">long l1 = 0x123_4567_89ab_cedf;
uint binary1 = 0b1111_1110_1101_1100_1011_1010_1001_1000;
uint binary2 = 0b111_110_101_100_011_010_001_000;
</code></pre>
<p>You can put the underscores at any position, you need to make sure it helps readability, <strong>not</strong> as shown in this example:</p>
<pre><code class="language-cs">long l3 = 0x12345_6789_abc_ed_f;
</code></pre>
<p>Digit separators are new with C# 7. C# 7.0 doesn't allow leading digit separators, having the separator before the value (and after the prefix). Leading digit separators can be used with C# 7.2.</p>
</blockquote>
<h2 id="predefined-reference-types">Predefined Reference Types</h2>
<h3 id="the-object-type-page-134">The object Type: Page 134</h3>
<blockquote>
<p>Many programming languages and class hierarchies provide a root type, from which all other objects in the hierarchy are derived. C# and .NET are no exception. In C#, the <em>object</em> type is the ultimate parent type from which all other intrinsic and user-defined types are derived. This means that you can use the <em>object</em> type for two purposes:</p>
<ul>
<li>You can use an <em>object</em> reference to bind to an <em>object</em> of any particular subtype. For example, in Chapter 6, “Operators and Casts,” you see how you can use the <em>object</em> type to box a value object on the stack to move it to the heap; <em>object</em> references are also useful in reflection, when code must manipulate objects whose specific types are unknown.</li>
<li>The <em>object</em> type implements a number of basic, general-purpose methods, which include Equals, <code>GetHashCode, GetType, and ToString</code>. Responsible user-defined classes might need to provide replacement implementations of some of these methods using an object-oriented technique known as <em>overriding</em>, which is discussed in Chapter 4, “Object Oriented Programming with C#.” When you override <code>ToString</code>, for example, you equip your class with a method for intelligently providing a string representation of itself. If you don’t provide your own implementations for these methods in your classes, the compiler picks up the implementations in <em>object</em>, which might or might not be correct or sensible in the context of your classes.</li>
</ul>
</blockquote>
<h3 id="the-string-type-page-134">The string Type: Page 134</h3>
<blockquote>
<p>Despite this style of assignment, <code>string</code> is a reference type. Behind the scenes, <strong>a <code>string</code> object is allocated on the heap, not the stack</strong>; and when you assign one <code>string</code> variable to another <code>string</code>, you get two references to the same <code>string</code> in memory. However, <code>string</code> differs from the usual behavior for reference types. For example, strings are immutable. Making changes to one of these strings creates an entirely new <code>string</code> object, leaving the other string unchanged. In general, the <code>string</code> class has been implemented so that its semantics follow what you would normally intuitively expect for a string.</p>
<p>You can prefix a string literal with the at character <code>@</code> and all the characters after it are treated at face value; they aren’t interpreted as escape sequences:</p>
<pre><code class="language-cs">string filepath = @&quot;C:\ProCSharp\First.cs&quot;;
</code></pre>
<p>This even enables you to include line breaks in your string literals:</p>
<pre><code class="language-cs">string jabberwocky = @&quot;'Twas brillig and the slithy toves
                        Did gyre and gimble in the wabe.&quot;;
</code></pre>
<p>In this case, the value of <code>jabberwocky</code> would be this:</p>
<pre><code class="language-cs">'Twas brillig and the slithy toves 
Did gyre and gimble in the wabe.
</code></pre>
</blockquote>
<h1 id="controlling-program-flow">CONTROLLING PROGRAM FLOW</h1>
<h2 id="conditional-statements">Conditional Statements</h2>
<ul>
<li>The if Statement: Page 138.</li>
<li>The switch Statement: Page 140.</li>
</ul>
<h2 id="loops">Loops</h2>
<ul>
<li>The for Loop: Page 143.</li>
<li>The while Loop: Page 146.</li>
<li>The do…while Loop: Page 146.</li>
<li>The foreach Loop: Page 147.</li>
</ul>
<h2 id="jump-statements">Jump Statements</h2>
<ul>
<li>The goto Statement: Page 148.</li>
<li>The break Statement: Page 148.</li>
<li>The continue Statement: Page 149.</li>
<li>The return Statement: Page 149</li>
</ul>
<h1 id="getting-organized-with-namespaces-page-149">GETTING ORGANIZED WITH NAMESPACES: Page 149</h1>
<blockquote>
<ul>
<li>Note that you are not permitted to declare a multipart namespace nested within another namespace.</li>
<li>Namespaces are not related to assemblies. It is perfectly acceptable to have different namespaces in the same assembly or to define types in the same namespace in different assemblies.</li>
<li>You should define the namespace hierarchy prior to starting a project. Generally the accepted format is <code>CompanyName.ProjectName.SystemSection</code>.</li>
</ul>
</blockquote>
<h2 id="the-using-directive-page-151">The using Directive: Page 151.</h2>
<blockquote>
<p>If two namespaces referenced by using statements contain a type of the same name, you need to use the full (or at least a longer) form of the name to ensure that the compiler knows which type to access. For example, suppose classes called <code>NamespaceExample</code> exist in both the <code>Wrox.ProCSharp.Basics</code> and <code>Wrox.ProCSharp.OOP</code> namespaces. If you then create a class called <code>Test</code> in the <code>Wrox.ProCSharp</code> namespace, and instantiate one of the <code>NamespaceExample</code> classes in this class, you need to specify which of these two classes you’re talking about:</p>
</blockquote>
<pre><code class="language-cs">using Wrox.ProCSharp.OOP; 
using Wrox.ProCSharp.Basics; 
namespace Wrox.ProCSharp 
{
    class Test 
    {
        static void Main() 
        {
            Basics.NamespaceExample nSEx = new
            Basics.NamespaceExample(); 
            // do something with the nSEx variable.
        } 
    } 
}
</code></pre>
<h2 id="namespace-aliases-page-152">Namespace Aliases: Page 152.</h2>
<pre><code class="language-cs">using alias = NamespaceName;
</code></pre>
<h1 id="understanding-the-main-method-page-153">UNDERSTANDING THE MAIN METHOD: Page 153</h1>
<blockquote>
<p>As described at the beginning of this chapter, C# programs start execution at a method named <code>Main</code>. Depending on the execution environment there are different requirements.</p>
<ul>
<li>Have a <em>static</em> modifier applied</li>
<li>Be in a class with any name</li>
<li>Return a type of <em>int</em> or <em>void</em></li>
</ul>
</blockquote>
<h1 id="using-comments">USING COMMENTS</h1>
<ul>
<li>Internal Comments Within the Source Files: Page 156.</li>
<li>XML Documentation: Page 156.</li>
</ul>
<h1 id="understanding-c-preprocessor-directives-page-158">UNDERSTANDING C# PREPROCESSOR DIRECTIVES: Page 158</h1>
<ul>
<li><code>#define</code> and <code>#undef</code>: Page 159.</li>
<li><code>#if, #elif, #else</code>, and <code>#endif</code>: Page 160.</li>
<li><code>#warning</code> and <code>#error</code>: Page 161.</li>
<li><code>#region</code> and <code>#endregion</code>: Page 162.</li>
<li><code>#line</code>: Page 162.</li>
<li><code>#pragma</code>: Page 163.</li>
</ul>
<h1 id="c-programming-guidelines">C# PROGRAMMING GUIDELINES</h1>
<ul>
<li>Rules for Identifiers: Page 163.</li>
<li>Usage Conventions: Page 166.</li>
</ul>
<h2 id="naming-conventions-page-167"><mark>Naming Conventions: Page 167</mark></h2>
<ul>
<li>Casing of Names: Page 168.</li>
<li>Name Styles: Page 169.</li>
<li>Namespace Names: Page 169.</li>
<li>Names and Keywords: Page 170.</li>
</ul>
<h2 id="use-of-properties-and-methods-page-170"><mark>Use of Properties and Methods: Page 170</mark></h2>
<blockquote>
<p>One area that can cause confusion regarding a class is whether a<br>
particular quantity should be represented by a property or a method. The rules are not hard and strict, but in general you should use a property if something should look and behave like a variable. (If you’re not sure what a property is, see Chapter 3.) This means, among other things, that</p>
<ul>
<li>Client code should be able to read its value. Write-only properties are not recommended, so, for example, use a <code>SetPassword</code> method, not a write-only Password property.</li>
<li>Reading the value should not take too long. The fact that something is a property usually suggests that reading it will be relatively quick.</li>
<li>Reading the value should not have any observable and unexpected side effect. Furthermore, setting the value of a property should not have any side effect that is not directly related to the property. Setting the width of a dialog has the obvious effect of changing the appearance of the dialog on the screen. That’s fine, because that’s obviously related to the property in question.</li>
<li>It should be possible to set properties in any order. In particular, it is not good practice when setting a property to throw an exception because another related property has not yet been set. For example, to use a class that accesses a database, you need to set <code>ConnectionString, UserName, and Password</code>, and then the author of the class should ensure that the class is implemented such that users can set them in any order.</li>
<li>Successive reads of a property should give the same result. If the value of a property is likely to change unpredictably, you should code it as a method instead. <code>Speed</code>, in a class that monitors the motion of an automobile, is not a good candidate for a property. Use a <code>GetSpeed</code> method here; but <code>Weight</code> and <code>EngineSize</code> are good candidates for properties because they will not change for a given object.</li>
</ul>
</blockquote>
<blockquote>
<p>If the item you are coding satisfies all the preceding criteria, it is probably a good candidate for a property. Otherwise, you should use a method.</p>
<p>Unlike fields, properties are not classified as variables. Therefore, you cannot pass a property as a ref or out parameter.</p>
</blockquote>
<h2 id="use-of-fields-page-172">Use of Fields: Page 172</h2>
<blockquote>
<p>The guidelines are pretty simple here. Fields should almost always be private, although in some cases it may be acceptable for constant or read-only fields to be public. Making a field public may hinder your ability to extend or modify the class in the future.</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《C#高级编程》笔记：Chapter 3 Objects and Types]]></title>
        <id>https://zhangyue-vhyt.github.io/post/Professional-Csharp-Chapter3/</id>
        <link href="https://zhangyue-vhyt.github.io/post/Professional-Csharp-Chapter3/">
        </link>
        <updated>2020-05-09T16:28:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="creating-and-using-classes">CREATING AND USING CLASSES</h1>
<p>Ignore</p>
<h1 id="classes-and-structs-page-175">CLASSES AND STRUCTS: Page 175</h1>
<blockquote>
<p>Structs differ from classes because they do not need to be allocated on the heap (classes are reference types and are always allocated on the heap). Structs are value types and are usually stored on the stack. Also, structs cannot derive from a base struct.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Class</th>
<th>Struct</th>
</tr>
</thead>
<tbody>
<tr>
<td>Heap</td>
<td>Stack</td>
</tr>
<tr>
<td>reference type</td>
<td>value type</td>
</tr>
<tr>
<td>can derive from a base class</td>
<td>can't derive from a base struct</td>
</tr>
</tbody>
</table>
<blockquote>
<p>You typically use structs for smaller data types for performance reasons. Storing value types on the stack avoids garbage collection. Another use case of structs are interop with native code; the layout of the struct can look the same as native data types.</p>
<p>For both classes and structs, you use the keyword <code>new</code> to declare an instance. This keyword creates the object and initializes it; in the following example, the default behavior is to zero out its fields:</p>
<pre><code class="language-cs"> var myCustomer = new PhoneCustomer(); // works for a class 
 var myCustomer2 = new PhoneCustomerStruct();// works for a struct
</code></pre>
<p>An important difference between classes and structs is that objects of type of class are passed by reference, and objects of type of a struct are passed by value.</p>
</blockquote>
<p>两者都是用 <code>new</code> 实例化，结构体有其他方法实例化。</p>
<h2 id="classes-page-177">CLASSES: Page 177</h2>
<h3 id="fields-page-179">Fields: Page 179</h3>
<p>Always private.</p>
<h3 id="readonly-fields-page-179">Readonly Fields: Page 179</h3>
<blockquote>
<p>To guarantee that fields of an object cannot be changed, you can declare fields with the <code>readonly</code> modifier. Fields with the <code>readonly</code> modifier can be assigned only values from constructors, which is different from the <code>const</code> modifier. With the <code>const</code> modifier, the compiler replaces the variable with its value everywhere it is used. The compiler already knows the value of the constant. Read-only fields are assigned during runtime from a constructor. Unlike const fields, readonly fields can be instance members. For using a read-only field as a class member, the <code>static</code> modifier needs to be assigned to the field.</p>
</blockquote>
<p><code>readonly</code>只能在构造函数中初始化，<code>const</code>必须在声明时初始化。</p>
<h3 id="properties-page-181">Properties: Page 181</h3>
<h4 id="expression-bodied-property-accessors-page-183">Expression-Bodied Property Accessors: Page 183</h4>
<pre><code class="language-cs">private string _firstName; 
public string FirstName 
{
    get =&gt; _firstName; 
    set =&gt; _firstName = value;
}
</code></pre>
<h4 id="auto-implemented-properties-page-183">Auto-Implemented Properties: Page 183</h4>
<pre><code class="language-cs">public int Age { get; set; }
</code></pre>
<h4 id="access-modifiers-for-properties-page-184">Access Modifiers for Properties: Page 184</h4>
<pre><code class="language-cs">public string Name 
{
    get =&gt; _name; 
    private set =&gt; _name = value;
}
</code></pre>
<pre><code class="language-cs">public int Age { get; private set; }
</code></pre>
<h4 id="read-only-properties-page-185">Read-Only Properties: Page 185</h4>
<pre><code class="language-cs">public string Name {get;}
</code></pre>
<blockquote>
<p>Similar to creating read-only properties it is also possible to create a <strong>write-only</strong> property. Write-only properties can be created by omitting the <code>get</code> accessor. However, this is regarded as poor programming practice because it could be confusing to authors of client code. In general, it is recommended that if you are tempted to do this, you should use a method instead.</p>
</blockquote>
<p>当低水平程序员使用我们的代码时，看到IDE提示一个属性只有<code>set</code>却无<code>get</code>会很困扰，所以 <strong>write-only</strong> 的属性应尽量避免使用，改用方法替代。</p>
<h4 id="auto-implemented-read-only-properties-page-186">Auto-Implemented Read-Only Properties: Page 186</h4>
<pre><code class="language-cs">public string Id { get; } = Guid.NewGuid().ToString();
</code></pre>
<h4 id="expression-bodied-properties-page-187">Expression-Bodied Properties: Page 187</h4>
<pre><code class="language-cs">public class Person 
{
    public Person(string firstName, string lastName) 
    {
        FirstName = firstName; 
        LastName = lastName;
    } 
    public string FirstName { get; } 
    public string LastName { get; } 
    public string FullName =&gt; $&quot;{FirstName} {LastName}&quot;;
}
</code></pre>
<h4 id="immutable-types-page-187">Immutable Types: Page 187</h4>
<blockquote>
<p>With the <code>readonly</code> modifier, the compiler complains if the state is changed. The state can be initialized only in the constructor.</p>
</blockquote>
<h4 id="anonymous-types-page-188">Anonymous Types: Page 188</h4>
<pre><code class="language-cs">var captain = new 
{
    FirstName = &quot;James&quot;, 
    MiddleName = &quot;T&quot;, 
    LastName = &quot;Kirk&quot;
};
</code></pre>
<h3 id="methods">Methods</h3>
<h4 id="declaring-methods-page-189">Declaring Methods: Page 189</h4>
<pre><code class="language-cs">[modifiers] return_type MethodName([parameters]) 
{
    // Method body 
}
</code></pre>
<h4 id="expression-bodied-methods-page-190">Expression-Bodied Methods: Page 190</h4>
<p>If the implementation of a method consists just of one statement, C# gives a simplified syntax to method definitions: <em>expression-bodied</em> methods.</p>
<pre><code class="language-cs">public bool IsSquare(Rectangle rect) =&gt; 
    rect.Height == rect.Width;
</code></pre>
<h4 id="invoking-methods-page-191">Invoking Methods: Page 191</h4>
<p>Ignore</p>
<h4 id="method-overloading-page-192">Method Overloading: Page 192</h4>
<p>Ignore</p>
<h4 id="named-arguments-page-193">Named Arguments: Page 193</h4>
<pre><code class="language-cs">r.MoveAndResize(x: 30, y: 40, width: 20, height: 40);
</code></pre>
<h4 id="optional-arguments-page-194">Optional Arguments: Page 194</h4>
<blockquote>
<p>Parameters can also be optional. You must supply a default value for optional parameters, which must be the last ones defined:</p>
<pre><code class="language-cs">public void TestMethod(int notOptionalNumber, int optionalNumber = 42) 
{
    Console.WriteLine(optionalNumber + notOptionalNumber); 
}
</code></pre>
<pre><code class="language-cs">public void TestMethod(int n, int opt1 = 11, int opt2 = 22, int opt3 = 33) 
{
    Console.WriteLine(n + opt1 + opt2 + opt3);
}
</code></pre>
</blockquote>
<p>可选参数必须在参数列表的最后，并声明缺省值。</p>
<blockquote>
<p>With multiple optional parameters, the feature of named arguments shines. Using named arguments, you can pass any of the optional parameters—for example, this example passes just the last one:</p>
<pre><code class="language-cs">TestMethod(1, opt3: 4);
</code></pre>
</blockquote>
<p>混合传参，参考 python。</p>
<h4 id="variable-number-of-arguments-page-195">Variable Number of Arguments: Page 195</h4>
<blockquote>
<p>Declaring the parameter of type array—the sample code uses an <code>int</code> array—and adding the <code>params</code> keyword, the method can be invoked using any number of <code>int</code> parameters.</p>
<pre><code class="language-cs">public void AnyNumberOfArguments(params int[] data) 
{
    foreach (var x in data) 
    {
        Console.WriteLine(x); 
    } 
}
</code></pre>
<p>If arguments of different types should be passed to methods, you can use an <code>object</code> array:</p>
<pre><code class="language-cs">public void AnyNumberOfArguments(params object[] data) 
{
    // ...
}
</code></pre>
<p>Now it is possible to use any type calling this method:</p>
<pre><code class="language-cs">AnyNumberOfArguments(&quot;text&quot;, 42);
</code></pre>
<p>If the <code>params</code> keyword is used with multiple parameters that are defined with the method signature, <mark><code>params</code> can be used only once, and it must be the last parameter</mark>:</p>
<pre><code class="language-cs">Console.WriteLine(string format, params object[] arg);
</code></pre>
</blockquote>
<h3 id="constructors-page-196">Constructors: Page 196</h3>
<h4 id="private-constructor-and-singleton-page-198">Private Constructor and Singleton: Page 198</h4>
<blockquote>
<ul>
<li>If your class serves only as a container for some static members or properties, and therefore should never be instantiated. With this scenario, you can declare the class with the modifier <code>static</code>. With this modifier the class can contain only static members and cannot be instantiated.</li>
<li>If you want the class to only ever be instantiated by calling a static member function (this is the so-called factory pattern approach to object instantiation). An implementation of the Singleton pattern is shown in the following code snippet.</li>
</ul>
</blockquote>
<pre><code class="language-cs">public class Singleton 
{
    private static Singleton s_instance; 
    private int _state; 
    private Singleton(int state) 
    {
        _state = state;
    } 
    public static Singleton Instance 
    {
        get =&gt; s_instance ?? (s_instance = new Singleton(42); 
    }
}
</code></pre>
<h4 id="expression-bodies-with-constructors-page-199">Expression Bodies with Constructors: Page 199</h4>
<pre><code class="language-cs">public class Singleton 
{
    private static Singleton s_instance; 
    private int _state; 
    private Singleton(int state) =&gt; _state = state;
    public static Singleton Instance =&gt; 
        s_instance ?? (s_instance = new Singleton(42);
}
</code></pre>
<h4 id="calling-constructors-from-other-constructors-page-199">Calling Constructors from Other Constructors: Page 199</h4>
<pre><code class="language-cs">class Car 
{
    private string _description; 
    private uint _nWheels;
    public Car(string description, uint nWheels) 
    {
        _description = description; 
        _nWheels = nWheels;
    }
    public Car(string description): this(description, 4) {} 
    // ...
}
</code></pre>
<h4 id="static-constructors-page-201">Static Constructors: Page 201</h4>
<ul>
<li>很少用到，需要用时看 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors">Microsoft Docs</a></li>
<li>The static constructor is guaranteed to run at most once.</li>
<li>No access modifiers.</li>
<li>No parameters.</li>
</ul>
<h1 id="structs-page-204">STRUCTS: Page 204</h1>
<p><mark>Struct 的大小不要超过64字节(bytes)</mark></p>
<blockquote>
<ul>
<li>Structs are value types, not reference types. This means they are stored either in the stack or inline (if they are part of another object that is stored on the heap) and have the same lifetime restrictions as the simple data types.</li>
<li>Structs do not support inheritance.</li>
<li>There are some differences in the way constructors work for structs. If you do not supply a default constructor, the compiler automatically creates one and initializes the members to its default values.</li>
<li>With a struct, you can specify how the fields are to be laid out in memory (this is examined in Chapter 16, which covers attributes).</li>
<li>Because structs are really intended to group data items together, you’ll sometimes find that most or all of their fields are declared as public.</li>
<li>Structs can also contain <em>constructors, constants, fields, methods, properties, indexers, operators, events, and nested types</em>, although if several such members are required, you should consider making your type a class instead.</li>
</ul>
</blockquote>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/struct">Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/write-safe-efficient-code">Write safe and efficient C# code</a></li>
</ul>
<h2 id="structs-are-value-types-page-206">Structs Are Value Types: Page 206</h2>
<blockquote>
<p>通常，可使用 <code>new</code> 运算符调用适当的构造函数来实例化结构类型。 每个结构类型都至少有一个构造函数。 这是一个隐式无参数构造函数，用于生成类型的默认值。 还可以使用默认运算符或文本来生成类型的默认值。</p>
<p>如果结构类型的所有实例字段都是可访问的，则还可以在不使用 <code>new</code> 运算符的情况下对其进行实例化。 在这种情况下，在首次使用实例之前必须初始化所有实例字段。 下面的示例演示如何执行此操作：</p>
<p>--- <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/struct">Microsoft Docs</a></p>
</blockquote>
<blockquote>
<pre><code class="language-cs">Dimensions point; 
point.Length = 3; 
point.Width = 6;
</code></pre>
<p>Structs follow the same rule as any other data type: Everything must be initialized before use. A struct is considered fully initialized either when the new operator has been called against it or when values have been individually assigned to all its fields. Also, of course, a struct defined as a member field of a class is initialized by being zeroed out automatically when the containing object is initialized.</p>
</blockquote>
<h2 id="readonly-structs-page-208">Readonly structs: Page 208</h2>
<blockquote>
<p>Declaring a <code>struct</code> using the readonly modifier informs the compiler that your intent is to create an immutable type. The compiler enforces that design decision with the following rules:</p>
<ul>
<li>All field members must be readonly</li>
<li>All properties must be read-only, including auto-implemented properties.</li>
</ul>
</blockquote>
<h2 id="structs-and-inheritance-page-209">Structs and Inheritance: Page 209</h2>
<blockquote>
<p>Structs are not designed for inheritance. This means it is not possible to inherit from a struct. The only exception to this is that structs, in common with every other type in C#, derive ultimately from the class <code>System.Object</code>.</p>
</blockquote>
<h2 id="constructors-for-structs-page-210">Constructors for Structs: Page 210</h2>
<blockquote>
<p>You can define constructors for structs in a similar way as you do it for classes.</p>
</blockquote>
<h2 id="ref-structs-page-210">ref structs: Page 210</h2>
<blockquote>
<p>With most applications you'll not have a need to create a custom <em>ref struct</em> type. However, for high-performance applications where garbage collection needs to be reduced, there's need for this type.</p>
</blockquote>
<h1 id="passing-parameters-by-value-and-by-reference-page-211">PASSING PARAMETERS BY VALUE AND BY REFERENCE: Page 211</h1>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/passing-reference-type-parameters">Microsoft Docs</a></li>
<li>不带<code>ref</code>关键字的引用类型传递的是引用的副本，和 java 一样。</li>
</ul>
<blockquote>
<pre><code class="language-cs">public static void ChangeA(A a) 
{
    a.X = 2; 
}

static void Main() 
{
    A a1 = new A { X = 1 }; 
    ChangeA(a1); 
    Console.WriteLine($&quot;a1.X: {a1.X}&quot;);
}
</code></pre>
<p>What would you guess is the output? 1 or 2?<br>
The answer is … it depends. You need to know if <code>A</code> is a class or a struct.</p>
<p>Structs are passed by value; with that the variable <code>a</code> from the <code>ChangeA</code> method gets a copy from the variable <code>a1</code> that is put on the stack. Only the copy is changed and destroyed at the end of the method ChangeA. The content of <code>a1</code> never changes and stays 1.</p>
<p>Classes are passed by reference. This way, <code>a</code> is a variable that references the same object on the heap as the variable <code>a1</code>. When <code>ChangeA</code> changes the value of the <code>X</code> property of <code>a</code>, the change makes it <code>a1.X</code> because it is the same object. Here, the result is 2.</p>
<p>To avoid this confusion on different behavior between classes and structs when members are changed, it’s a good practice to make structs immutable.</p>
</blockquote>
<h2 id="ref-parameters-page-213">ref Parameters: Page 213</h2>
<blockquote>
<p>Using the ref modifier with A as a class type, a reference to a reference (or in C++ jargon, a pointer to a pointer) is passed。</p>
</blockquote>
<p>书上这段不一定对，C#的 <code>ref</code> 并不等于二级指针。详情参考文档</p>
<blockquote>
<p><code>ref</code> 关键字让形参成为实参的别名，这必须是变量。换而言之，对形参执行的任何操作都是对实参执行的。</p>
<p>--- <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref">Microsoft Docs</a></p>
</blockquote>
<h2 id="out-parameters-page-214">out Parameters: Page 214</h2>
<blockquote>
<p>它与 <code>ref</code> 关键字相似，只不过 <code>ref</code> 要求在传递之前初始化变量。 它也类似于 <code>in</code> 关键字，只不过 <code>in</code> 不允许通过调用方法来修改参数值。 若要使用 <code>out</code> 参数，方法定义和调用方法均必须显式使用 <code>out</code> 关键字。</p>
<p>作为 <code>out</code> 参数传递的变量在方法调用中传递之前不必进行初始化。 但是，被调用的方法需要在返回之前赋一个值。</p>
<p>使用 <code>out</code> 参数声明方法是返回多个值的经典解决方法。 自 C# 7.0 起，建议在类似方案中使用元组。</p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/out-parameter-modifier#calling-a-method-with-an-out-argument">调用具有 out 参数的方法:</a></p>
<pre><code class="language-cs">string numberAsString = &quot;1640&quot;;

if (Int32.TryParse(numberAsString, out var number))
    Console.WriteLine($&quot;Converted '{numberAsString}' to {number}&quot;);
else
    Console.WriteLine($&quot;Unable to convert '{numberAsString}'&quot;);
// The example displays the following output:
//       Converted '1640' to 1640
</code></pre>
<p>--- <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/out-parameter-modifier#calling-a-method-with-an-out-argument">Microsoft Docs</a></p>
</blockquote>
<h2 id="in-parameters-page-216">in Parameters: Page 216</h2>
<blockquote>
<p>The in modifier makes the parameter a <code>readonly</code> variable</p>
</blockquote>
<p>用 <code>in</code> 传递值类型时，形参为只读类型。</p>
<blockquote>
<p>The <code>in</code> modifier is mainly used with value types. However, you can use it with reference types as well. When using the <code>in</code> modifier with reference types, you can change the content of the variable, but not the variable itself.</p>
</blockquote>
<p>用 <code>in</code> 传递引用类型时，形参绑定的对象固定，不能把形参绑定到其他对象上。这点和不用 <code>in</code> 传递引用类型是一样的，所以 <code>in</code> 传递引用类型不常见。</p>
<blockquote>
<p>作为 <code>in</code> 参数传递的变量在方法调用中传递之前必须进行初始化。 但是，所调用的方法可能不会分配值或修改参数。</p>
<p>--- <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/in-parameter-modifier">Microsoft Docs</a></p>
</blockquote>
<h1 id="nullable-types-page-217">NULLABLE TYPES: Page 217</h1>
<blockquote>
<p>With the following code snippet, <code>x1</code> is a normal <em>int</em>, and <code>x2</code> is a <em>nullable int</em>. Because <code>x2</code> is a <em>nullable int</em>, <code>null</code> can be assigned to <em>x2</em>:</p>
<pre><code class="language-cs">int x1 = 1; 
int? x2 = null;
</code></pre>
</blockquote>
<blockquote>
<p>Because an <code>int</code> cannot have a value that cannot be assigned to <code>int?</code>, passing a variable of <code>int</code> to <code>int?</code> always succeeds and is accepted from the compiler:</p>
<pre><code class="language-cs">int? x3 = x1;
</code></pre>
</blockquote>
<p>可空类型赋值为普通类型可以直接赋值。</p>
<blockquote>
<p>The reverse is not true. <code>int?</code> cannot be directly assigned to <code>int</code>. This can fail, and thus a cast is required:</p>
<pre><code class="language-cs">int x4 = (int) x3;
</code></pre>
</blockquote>
<p>普通类型赋值为可空类型必须显性转换 (<code>cast</code>)。</p>
<blockquote>
<p>Using the coalescing operator <code>??</code>, there’s a shorter syntax possible with nullable types. In a case where <code>x3</code> is <code>null</code>, <code>−1</code> is set with the variable <code>x6</code>; otherwise you take the value of <code>x3</code>:</p>
<pre><code class="language-cs">int x6 = x3 ?? -1;
</code></pre>
</blockquote>
<p>双问号前是非空情况的赋值，双问号后是为空情况的赋值。</p>
<blockquote>
<p>With nullable types, you can use all operators that are available with the underlying types—for example, <code>+, -, *, /</code> and more with <code>int?</code>. You can use nullable types with every struct type, not only with predefined C# types. You can read more about nullable types and what’s behind the scenes in Chapter 5, “Generics.”</p>
</blockquote>
<p>所有 <code>struct</code> 类型都可以作为可空类型。</p>
<h1 id="enum-types-page-219">ENUM TYPES: Page 219</h1>
<blockquote>
<p>An enumeration is a value type that contains a list of named constants, such as the Color type shown here. The enumeration type is defined by using the enum keyword (code file <code>EnumSample/Color.cs</code>):</p>
<pre><code class="language-cs">public enum Color {
   Red, 
   Green, 
   Blue
}
</code></pre>
</blockquote>
<p>枚举类型的声明。</p>
<blockquote>
<p>You can declare variables of enum types, such as the variable c1, and assign a value from the enumeration by setting one of the named constants prefixed with the name of the enum type</p>
<pre><code class="language-cs">private static void ColorSamples() 
{
    Color c1 = Color.Red; 
    Console.WriteLine(c1); //...
}
</code></pre>
</blockquote>
<p>枚举类型的调用。</p>
<blockquote>
<p>By default, the type behind the enum type is an int. The underlying type can be changed to other integral types (byte, short, int, long with signed and unsigned variants). The values of the named constants are incremental values starting with 0, but they can be changed to other values:</p>
<pre><code class="language-cs">public enum Color : short 
{
    Red = 1, 
    Green = 2, 
    Blue = 3
}
</code></pre>
</blockquote>
<p>枚举类型默认是整型，声明时可以在冒号后指定类型。</p>
<blockquote>
<p>You can change a number to an enumeration value and back using casts.</p>
<pre><code class="language-cs">Color c2 = (Color)2; 
short number = (short)c2;
</code></pre>
</blockquote>
<p>枚举类型可以和普通类型进行显示转换。</p>
<blockquote>
<p>You can also use an enum type to assign multiple options to a variable and not just one of the enum constants. To do this, the values assigned to the constants must be <strong>different bits</strong>, and the <code>Flags</code> attribute needs to be set with the enum.</p>
<pre><code class="language-cs">[Flags] 
public enum DaysOfWeek 
{
    Monday = 0x1, 
    Tuesday = 0x2, 
    Wednesday = 0x4, 
    Thursday = 0x8, 
    Friday = 0x10, 
    Saturday = 0x20, 
    Sunday = 0x40
}
</code></pre>
<pre><code class="language-cs">DaysOfWeek mondayAndWednesday = DaysOfWeek.Monday | DaysOfWeek.Wednesday; 
Console.WriteLine(mondayAndWednesday);
</code></pre>
<pre><code class="language-sh">Monday, Tuesday
</code></pre>
</blockquote>
<p>一个变量赋值多个枚举值，需要在声明枚举类型时时添加 <code>[Flags]</code> 特性。</p>
<blockquote>
<p>Setting different bits, it is also possible to combine single bits to cover multiple values, such as Weekend with a value of <code>0x60</code> that combines Saturday and Sunday with the logical OR operator, Workday to combine all the days from Monday to Friday, and AllWeek to combine Workday and Weekend with the logical OR operator (code file <code>EnumSample/DaysOfWeek.cs</code>):</p>
<pre><code class="language-cs">[Flags] 
public enum DaysOfWeek 
{
    Monday = 0x1, 
    Tuesday = 0x2, 
    Wednesday = 0x4, 
    Thursday = 0x8, 
    Friday = 0x10, 
    Saturday = 0x20, 
    Sunday = 0x40, 
    Weekend = Saturday | Sunday,
    Workday = 0x1f, 
    AllWeek = Workday | Weekend
}
</code></pre>
</blockquote>
<p>枚举类型与位运算相结合的高级用法。</p>
<h1 id="partial-classes-page-222">PARTIAL CLASSES: Page 222</h1>
<blockquote>
<p>To use the <code>partial</code> keyword, simply place partial before <em>class, struct, or interface</em>. In the following example, the class <code>SampleClass</code> resides in two separate source files, <code>SampleClassAutogenerated.cs</code> and <code>SampleClass.cs</code>:</p>
<pre><code class="language-cs">//SampleClassAutogenerated.cs 
partial class SampleClass 
{
    public void MethodOne() { } 
}
</code></pre>
<pre><code class="language-cs">//SampleClass.cs 
partial class SampleClass 
{
    public void MethodTwo() { } 
}
</code></pre>
<p>If any of the following keywords are used in describing the class, the same must apply to all partials of the same type:</p>
<ul>
<li>public</li>
<li>private</li>
<li>protected</li>
<li>internal</li>
<li>abstract</li>
<li>sealed</li>
<li>new</li>
<li>generic constraints</li>
</ul>
</blockquote>
<p>局部类是 C# 独有的精华。</p>
<blockquote>
<p>Partial classes can contain <em>partial methods</em>. This is extremely useful if generated code should invoke methods that might not exist at all. The programmer extending the partial class can decide to create a custom implementation of the partial method, or do nothing. The following code snippet contains a partial class with the method MethodOne that invokes the method <code>APartialMethod</code>. The method <code>APartialMethod</code> is declared with the partial keyword; thus, it does not need any implementation. If there’s not an implementation, the compiler removes the invocation of this method:</p>
<pre><code class="language-cs">//SampleClassAutogenerated.cs 
partial class SampleClass 
{
    public void MethodOne() 
    {
        APartialMethod();
    } 

    public partial void APartialMethod();
}
</code></pre>
<p>An implementation of the partial method can be done within any other part of the partial class, as shown in the following code snippet. With this method in place, the compiler creates code within <code>MethodOne</code> to invoke this <code>APartialMethod</code> declared here:</p>
<pre><code class="language-cs">// SampleClass.cs 
partial class SampleClass: IOtherSampleClass 
{
    public void APartialMethod() 
    {
        // implementation of APartialMethod 
    } 
}
</code></pre>
<p>A partial method needs to be of type <code>void</code>. Otherwise the compiler cannot remove the invocation in case no implementation exists.</p>
</blockquote>
<ul>
<li>局部类中可以包含局部方法。</li>
<li>局部方法的思路大致是这样：方法声明和方法实现可以分开来做。</li>
<li>局部方法不能被外部直接调用，不可以加上类似 <code>public</code> 这样的访问修饰符。</li>
<li>局部方法的作用是这样：我们在设计一个类型的时候，某个操作是需要的，但在类型设计阶段还不知道如何实现。所以，我们需要先放置一个占位符。</li>
<li>局部方法可以只声明不实现，编译器会忽略未实现的方法。</li>
<li>局部方法必须是 <code>void</code> 类型。</li>
<li>在任何使用 <code>Partial</code> 方法的地方，我们都可以用 <code>delegate</code> 去实现。</li>
</ul>
<h1 id="extension-methods-page-225">EXTENSION METHODS: Page 225</h1>
<blockquote>
<p>Extension methods are static methods that can look like part of a class without actually being in the source code for the class.</p>
</blockquote>
<p>拓展方法必须是静态的。</p>
<blockquote>
<p>Extension methods can be used to extend interfaces. This way you can have common functionality for all the classes that implement this interface. Interfaces are explained in Chapter 4.</p>
</blockquote>
<p>拓展方法可以拓展接口。</p>
<blockquote>
<p>This option is also possible when inheritance cannot be used (for example, the class is sealed).</p>
</blockquote>
<p>拓展方法可以不作用于子类。</p>
<p>详情参考 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/extension-methods">Microsoft Docs</a></p>
<h1 id="the-object-class-page-227">THE OBJECT CLASS: Page 227</h1>
<blockquote>
<p>For the time being, the following list summarizes the purpose of each method:</p>
<ul>
<li><code>ToString</code>:A fairly basic, quick-and-easy string representation. Use it when you want a quick idea of the contents of an object, perhaps for debugging purposes. It provides very little choice regarding how to format the data. For example, dates can, in principle, be expressed in a huge variety of formats, but <code>DateTime</code>.<code>ToString</code> does not offer you any choice in this regard. If you need a more sophisticated string representation—for example, one that takes into account your formatting preferences or the culture (the locale) —then you should implement the <code>IFormattable</code> interface (see Chapter 9, “Strings and Regular Expressions”).</li>
<li><code>GetHashCode</code>: If objects are placed in a data structure known as a map (also known as a hash table or dictionary), it is used by classes that manipulate these structures to determine where to place an object in the structure. If you intend your class to be used as a key for a dictionary, you need to override <code>GetHashCode</code>. Some fairly strict requirements exist for how you implement your overload, which you learn about when you examine dictionaries in Chapter 10, “Collections.”</li>
<li><code>Equals</code> (both versions) and <code>ReferenceEquals</code>: As you'll note by the existence of three different methods aimed at comparing the equality of objects, the .NET Framework has quite a sophisticated scheme for measuring equality. Subtle differences exist between how these three methods, along with the comparison operator, ==, are intended to be used. In addition, restrictions exist on how you should override the virtual, one-parameter version of <code>Equals</code> if you choose to do so, because certain base classes in the <code>System.Collections</code> namespace call the method and expect it to behave in certain ways. You explore the use of these methods in Chapter 6 when you examine operators.</li>
<li><code>Finalize</code>: Covered in Chapter 17, this method is intended as the nearest that C# has to C++-style destructors. It is called when a reference object is garbage collected to clean up resources. The <code>Object</code> implementation of <code>Finalize</code> doesn’t actually do anything and is ignored by the garbage collector. You normally override Finalize if an object owns references to unmanaged resources that need to be removed when the object is deleted. The garbage collector cannot do this directly because it only knows about managed resources, so it relies on any finalizers that you supply.</li>
<li><code>GetType</code>: This object returns an instance of a class derived from <code>System.Type</code>, so it can provide an extensive range of information about the class of which your object is a member, including base type, methods, properties, and so on. <code>System.Type</code> also provides the entry point into .NET’s reflection technology. Chapter 16 examines this topic.</li>
<li><code>MemberwiseClone</code>: The only member of <code>System.Object</code> that isn't examined in detail anywhere in the book. That's because it is fairly simple in concept. It just makes a copy of the object and returns a reference (or in the case of a value type, a boxed reference) to the copy. Note that the copy made is a shallow copy, meaning it copies all the value types in the class. If the class contains any embedded references, then only the references are copied, not the objects referred to. This method is protected and cannot be called to copy external objects. Nor is it virtual, so you cannot override its implementation.</li>
</ul>
</blockquote>
<p>这部分太底层，暂时不用学。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[How To Make C# Discord Bot]]></title>
        <id>https://zhangyue-vhyt.github.io/post/how-to-make-csharp-discord-bot/</id>
        <link href="https://zhangyue-vhyt.github.io/post/how-to-make-csharp-discord-bot/">
        </link>
        <updated>2020-04-18T09:23:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>此文是跟着视频 <a href="https://www.youtube.com/playlist?list=PLS6sInD7ThM0Zb8F_KBl4T_jGF1e3apsc">How To Make C# Discord Bot</a> 学习时需要注意的地方，主要是使用新方案替代视频中已经不可用的旧方案。</p>
<h1 id="how-to-make-a-c-discord-bot-setting-up-part-1"><a href="https://youtu.be/7-tyLCAO4mY">How To Make A C# Discord Bot - Setting Up - Part 1</a></h1>
<ol>
<li><code>CommandsNextModule</code> -&gt; <code>CommandsNextExtension</code></li>
<li>在定义 <code>Config</code> 对象时，使用 <code>DTO class</code> 替代视频中的 <code>struct</code>。</li>
<li>使用 <code>dotnet core 3.0+</code> 自带的 <code>System.Text.Json</code> 替代 <code>Newtonsoft.Json</code></li>
</ol>
<pre><code class="language-csharp">ConfigDTO configDTO;
using(FileStream fs = File.OpenRead(&quot;config.json&quot;))
{
    configDTO = await JsonSerializer.DeserializeAsync&lt;ConfigDTO&gt;
        (
            fs,
            new JsonSerializerOptions { PropertyNameCaseInsensitive = true }
        );
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工具箱]]></title>
        <id>https://zhangyue-vhyt.github.io/post/tools/</id>
        <link href="https://zhangyue-vhyt.github.io/post/tools/">
        </link>
        <updated>2020-04-17T20:23:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="documents">Documents</h1>
<h2 id="google-docs">Google Docs</h2>
<ul>
<li><a href="https://vizzlo.com/">Vizzlo 画图工具</a></li>
</ul>
<h1 id="ai">AI</h1>
<ul>
<li><a href="https://essay.1ts.fun/">AI写论文-小论文神器</a></li>
<li><a href="https://aimwriting.mtutor.engkoo.com/#more">AI检查英语作文-微软小英爱写作</a></li>
<li><a href="https://wyc.5118.com/?t=zhihu&amp;id=20950693&amp;u=yuan_xing_ke">AI智能原创-5118大数据平台</a></li>
<li><a href="https://www.giiso.com/#/">AI写自媒体稿子-Giiso写作机器人</a></li>
<li><a href="http://jiuge.thunlp.cn/fengge.html">AI写诗-九歌</a></li>
<li><a href="https://petalica-paint.pixiv.dev/index_zh.html">AI作画-自动给画上色</a></li>
<li><a href="https://bigjpg.com/">AI无损放大图片</a></li>
<li><a href="http://duilian.msra.cn/app/couplet.aspx">AI写对联-微软对对联</a></li>
<li><a href="http://www.seeprettyface.com/index.html">AI生成照片-高颜值人脸AI生成器</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 中创建 const 常量]]></title>
        <id>https://zhangyue-vhyt.github.io/post/create-constant-in-python/</id>
        <link href="https://zhangyue-vhyt.github.io/post/create-constant-in-python/">
        </link>
        <updated>2020-04-03T20:44:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>Python 没有 <code>const</code> 关键字，想要创建常量只能自己想办法。<br>
这篇笔记介绍的是使用私有变量、单例模式、只读属性和不可变类型创建一个 <code>Constant</code> 类，在其中储存和调用所需要的常量值。</p>
<h1 id="私有变量">私有变量<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h1>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线 <code>__</code>，在Python中，实例的变量名如果以 <code>__</code> 开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>
<h1 id="单例模式">单例模式<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></h1>
<pre><code class="language-py">class Constant(object):
    &quot;&quot;&quot;
    A singleton class to store all constants.
    &quot;&quot;&quot;

    __instance = None

    def __new__(cls, *args, **kw):
        if cls.__instance is None:
            cls.__instance = object.__new__(cls, *args, **kw)
        return cls.__instance
</code></pre>
<h1 id="只读属性">只读属性<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></h1>
<p>Python 中的属性<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>和 C# 中的属性是同一个概念。</p>
<pre><code class="language-py">class People:

    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    @property
    def age(self):
        return self.__age

    @age.setter
    def age(self, age):
        if isinstance(age, int):
            self.__age = age
        else:
            raise ValueError

    @age.deleter
    def age(self):
        print(&quot;删除年龄数据！&quot;)

obj = People(&quot;jack&quot;, 18)
print(obj.age)
obj.age = 19
print(&quot;obj.age:  &quot;, obj.age)
del obj.age

---------------------------
打印结果：
18
obj.age:   19
删除年龄数据！
</code></pre>
<p>那么如何将一个普通的方法转换为一个“伪装”的属性呢？</p>
<ul>
<li>首先，在普通方法的基础上添加 <code>@property</code> 装饰器，例如上面的 <code>age()</code> 方法。这相当于一个 <code>get</code> 方法，用于获取值,决定类似 <code>result = obj.age</code> 执行什么代码。该方法仅有一个<code>self</code> 参数。</li>
<li>写一个同名的方法，添加 <code>@xxx.setter</code> 装饰器（xxx表示和上面方法一样的名字），比如例子中的第二个方法。这相当于编写了一个 <code>set</code> 方法，提供赋值功能，决定类似 <code>obj.age = ....</code> 的语句执行什么代码。</li>
<li>再写一个同名的方法，并添加 <code>@xxx.delete</code> 装饰器，比如例子中的第三个方法。用于删除功能，决定 <code>del obj.age</code> 这样的语句具体执行什么代码。</li>
</ul>
<p>简而言之，就是分别将三个方法定义为对同一个属性的获取、修改和删除。还可以定义只读属性，只需要使用 <code>@property</code> 声明 <code>get</code> 方法，不定义 <code>setter</code> 方法就是一个只读属性。</p>
<pre><code class="language-py">class Constant(object):
    def __init__(self):
        self.__val = 1

    @property
    def val(self):
        return self.__val
</code></pre>
<h1 id="不可变类型">不可变类型</h1>
<p>常量是不可变类型的子集，区别在于不可变类型的变量名可以重新绑定到其他类型上，而常量名和常量值都是不可变的。</p>
<pre><code class="language-py">a = (1, 2, 3)   # 元组是一个不可变类型
print(a)
a = 1   # 原本绑定到不可变类型的变量名可以重新绑定到其他值
print(a)

---------------------------
输出：
(1, 2, 3)
1
</code></pre>
<h2 id="不可变字典">不可变字典</h2>
<p>可变类型 <code>list</code> 和 <code>set</code> 对应的不可变类型分别为 <code>tuple</code> 和 <code>frozenset</code>。但在 <a href="https://www.python.org/dev/peps/pep-0416/#implementation">PEP 416</a> 中拒绝了不可变字典的要求。因此我们使用 Python 3.3 中引入的 <code>MappingProxyType</code> 和私有变量搭配实现不可变字典的返回。</p>
<pre><code class="language-py">from types import MappingProxyType


class Constant(object):
    &quot;&quot;&quot;
    A singleton class to store all constants.
    &quot;&quot;&quot;

    __instance = None

    def __new__(cls, *args, **kw):
        if cls.__instance is None:
            cls.__instance = object.__new__(cls, *args, **kw)
        return cls.__instance

    def __init__(self):
        self.__dict1 = {a:1, b:2}

    @property
    def dict1(self):
        return MappingProxyType(self.__dict1).copy()
</code></pre>
<h1 id="使用常量">使用常量</h1>
<p><code>Constant</code> 是一个类，所以我们需要先实例化才能使用它。</p>
<pre><code class="language-py">const = Constant()
dict1 = const.dict1
</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017496679217440">廖雪峰的 Python 教程</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/37534850">Python单例模式(Singleton)的N种实现</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://cloud.tencent.com/developer/article/1365783">python <code>@property</code> 设置只读属性 重写 <code>getter</code> <code>setter</code> 方法</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a href="https://www.liujiangblog.com/course/python/46">刘江的博客教程</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[黑色沙漠M 导入韩服捏脸数据]]></title>
        <id>https://zhangyue-vhyt.github.io/post/bdm-beauty-transfer/</id>
        <link href="https://zhangyue-vhyt.github.io/post/bdm-beauty-transfer/">
        </link>
        <updated>2020-04-01T03:24:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="模拟器">模拟器</h1>
<p>夜神、雷电、蓝叠</p>
<h1 id="安装-es-file-explore">安装 ES File Explore</h1>
<p>直接 <code>Google Play</code> 下载</p>
<h1 id="下载-qooapp-并安装">下载 QooApp 并安装</h1>
<p>模拟器中的浏览器搜索 <code>QooApp</code>, 官网不一定下得到，可以从第三方下载</p>
<h1 id="安装黑沙">安装黑沙</h1>
<p><code>QooApp</code> 中搜索 <code>black desert mobile</code>，日韩台服都有</p>
<h1 id="运行黑沙">运行黑沙</h1>
<p>墙外无任何困难</p>
<h1 id="按作者搜索捏脸作品">按作者搜索捏脸作品</h1>
<p>需要复制作者姓名，如果是韩语并且是图片，使用 <a href="https://online.easyscreenocr.com/Home/KoreanOCR">OCR 工具</a></p>
<h1 id="导出导入-捏脸数据">导出/导入 捏脸数据</h1>
<ol>
<li>关闭游戏，关闭模拟器。</li>
<li>克隆备份模拟器。</li>
<li>在备份模拟器中开游戏。</li>
<li>导出捏脸数据。<br>
<img src="https://truth.bahamut.com.tw/s01/201812/19900231d8b37a5f62c51a6c278d32aa.JPG" alt="image" loading="lazy"></li>
<li>关闭韩服。</li>
<li>打开美服，进入角色捏脸界面，右上角缓存一下建立缓存文件。</li>
<li>打开 <code>ES File Explorer</code>。</li>
<li><code>root</code> 权限打开，导出的数据在<code>/data/data/com.pearlabyss.blackdesertm/files/res/customization</code>文件夹。第二个<code>data</code>文件夹可能会变动。</li>
<li>同样复制一份数据到 <code>/mnt/shared/Pictures</code>。<br>
<img src="https://truth.bahamut.com.tw/s01/201812/de78ecc725b5ac88bd746746881db850.JPG" alt="image" loading="lazy"></li>
<li>通过模拟器与 PC 共享文件，导出数据到 PC 以作备份。</li>
<li>将所需要的数据黏贴到<code>/data/data/com.pearlabyss.blackdesertm.gl/files/res/customization</code>。</li>
<li>打开美服，载入数据。</li>
<li>如果失败，调用备份模拟器和数据。</li>
</ol>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://forum.gamer.com.tw/C.php?bsn=32841&amp;snA=7859">【攻略】韓版、台版捏臉數據導出教學(圖多) 12/6修改</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[黑色沙漠M 美服 Heidel 华人公会]]></title>
        <id>https://zhangyue-vhyt.github.io/post/bdm-na-guild/</id>
        <link href="https://zhangyue-vhyt.github.io/post/bdm-na-guild/">
        </link>
        <updated>2020-03-31T16:05:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="discord">Discord</h1>
<p>手动加入 <code>discord.gg/pj5YEDj</code> 或者点击 <a href="https://discord.gg/pj5YEDj">这里</a></p>
<h1 id="微信群">微信群</h1>
<p>如有需要请在加入 Discord 之后请大佬拉进群。</p>
<h1 id="公会每日任务">公会每日任务<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h1>
<p><img src="https://zhangyue-vhyt.github.io/post-images/1585841757419.jpg" alt="" loading="lazy"><br>
<img src="https://zhangyue-vhyt.github.io/post-images/1585841764714.jpg" alt="" loading="lazy"><br>
<img src="https://zhangyue-vhyt.github.io/post-images/1585841769264.jpg" alt="" loading="lazy"></p>
<h1 id="鸣谢">鸣谢</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>工会成员 FenrirWolf 制作的工会每日任务教程。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://zhangyue-vhyt.github.io/post/hello-gridea/</id>
        <link href="https://zhangyue-vhyt.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>